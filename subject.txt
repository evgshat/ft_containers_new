* For each container, turn in the appropriately named class files.
* SFINAE — правило языка C++, связанное с шаблонами и перегрузкой функций.
* Вы должны использовать std::allocator.
* Для перегрузок, не являющихся членами, разрешено ключевое слово friend. Каждое использование друга
должны быть обоснованы и будут проверены во время оценки.

STL - Standart Template Library - стандартная библиотека шаблонов в с++.
Контейнер - шаблонный класс, который может хранить внутри себя данные различных типов.

Начать со стека на стандартном векторе

Синглтон
Назначение паттерна Синглтон (или Одиночка) заключается в обеспечении доступа
к некоторому уникальному объекту из любой точки приложения.
Под уникальностью подразумевается, что такой объект существует в памяти в единственном экземпляре
и другие экземпляры созданы быть не могут.
Без условия уникальности Синглтон является обычной глобальной переменной

is_nothrow_default_constructible определен в <type_traits>
template< class T >
struct is_nothrow_default_constructible;
1) Если std::is_constructible<T>::value имеет значение true ,
 value константы члена равно true , в противном случае value равно false .

2) Если std::is_trivially_constructible<T>::value имеет значение true ,
 value константы члена равно true , в противном случае value равно false .

3) Если std::is_nothrow_constructible<T>::value имеет значение true ,
 value константы члена равно true , в противном случае value равно false .

 _LIBCPP_TEMPLATE_VIS - макрос видимости символа
 читай тут - https://bcain-llvm.readthedocs.io/projects/libcxx/en/latest/DesignDocs/VisibilityMacros.html

_NOEXCEPT_
 noexcept(false) означает, что функция относится к классу потенциально выбрасывающих исключения функций.
то же, что и throw ()

#pragma once — препроцессорная директива, разработанная для контроля за тем,
чтобы конкретный исходный файл при компиляции подключался строго один раз

#pragma - Директива компилятора.
Делает много чего, например, может запускать программу в мультитреде или управлять упаковкой структур в памяти.
она сильно компиляторнозависимая
#pragma comment lib - позволяет передать линковщику имя библиотки,
которую нужно подключить при линковке.
Для gcc - https://gcc.gnu.org/onlinedocs/gcc/Pragmas.html

#pragma GCC system_header - говорит, что остальная часть файла
(видимо то, что после этой строчки) - это часть системного заголовка.
Не там где написано include, а только этот файл

ключевое слово "typename" - это мы явно указываем компилятору, что речь идет о типе

constexpr — спецификатор типа, введённый в стандарт программирования языка C++11 для обозначения константных выражений, которые могут быть вычислены во время компиляции кода.

explicit - изначально, предотвращение неявного преобразования типов в конструкторах при инициализации
Например, конструкция MyClass a = 10, конвертируется в MyClass a(10). Но если поставить explicit -  то этого неявного преобразования не будет.

SFINAE - правило языка С++, связанное с шаблонами и перегрузкой функций.
Правило гласит: если не получается рассчитать окончательные типы/значения шаблонных параметров функций, компилятор не выбрасывает ошибку, а ищет другую подходящую перегрузку.
Сбой подстановки параметров шаблона не является ошибкой.
Ошибка будет если:
	1) не нашлось подходящей перегрузки
	2) нашлось несколько таких перегрузок и компилятор не может решить, какую взять
	3) перегрузка нашлась, она оказалась шаблонной, и при инстанцировании (создание экзмепляра класса) шаблона случилась ошибка

Boost - собрание библиотек классов, используюших функционал с++.
В boost добавили шаблон enable_if, действующий на правиле SFINAE и позволяющий инстанцировать шаблон при определенных условиях.
enable_if - if, который вычисляется во время компиляции.
	template< bool B, class T = void >
	struct enable_if;
enable_if выводит тип T, если выражение B истино
	template <bool B, class T = void>
	using enable_if_t = typename enable_if<B,T>::type;
if constexpr

Идентификаторы за пределами пространства имен могут получить доступы к членам с помощью полного имени для каждого идентификатора, например:
std::vector<std::string> vec;
Пространства имен могут быть вложенными

this - указатель на текущий объект данного класса, через него внутри класса можно обратиться к любым членам
std::is_integral - проверяет, является ли тип целочисленным

классы и шаблоны в <type_traits> используются для поддержки вывода типов, классификации и преобразования во время компиляции
вообще, traits переводиться как "свойства"
Другое название "класс свойств" - это класс, используемый вместо параметров шаблона. В качестве класса он объединяет полезные типы и констнаты;
как шаблон, он является средством для обеспечения того "дополнительного уровня косвенности", который решает все проблемы программного обеспечения
Пример:
 можно реализовать сл.шаблонный класс:
template<typename T,
		 typename ArgT      = const T&,
		 typename RefT      = T&,
		 typename ConstRefT = const T&>
class vector
{
	...
	public:
	 typedef T		value_type;
	 typedef argT	arg_type;
	 typedef RefT	reference;
	 typedef ConstRefT	const_reference;
}
это не всегда удобно, поэтому создают класс "класс свойств":
template<typename T>
class elem_traits
{
	...
	public:
	 typedef const T&	arg_type;
	 typedef 	   T&	reference;
	 typedef const T&	const_referecnce;
}
... и далее, вышеописанные класс свойст можно использовать в параметрах шаблона, например:
template<typename T, typename traits = elem_traits<T>>
class vector
{
	typedef T	value_type;
	typedef typename traits::arg_type			arg_type;
	typedef typename traits::reference			reference;
	typedef typename traits::const_reference	const_reference;
}
тогда, если мы создадим
vector<int> vec1 - то это будет эквивалентно vector<int, elem_traits<int> >
