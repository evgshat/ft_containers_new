Вопросы:

1. В каких случаях перед переменной ставится "_"? Пример: _Т
2. template <> - что это означает? Перед классом
3. Если я в объявлении написала конструкцию типа:
    void test (allocator_type& alloc = allocator_type())
   , то надо ли в реализации снова прописывать "allocator_type"? - нет
4. Вопрос, когда прописываем реализацию функции. Если мы прописываем тип возвращаемого значения, то мы должны брать его из класса:
    typename test_class<T, Allocator>::test type
    но при этом, когда перечисляем параметры в ф-ии, то мы нестандартный тип "не вытаскиваем" из шаблона:
    test_type test(new_test_type)) - почему так?;
5. В namespace ft не получается использовать конструкцию std::cout - почему так? 

Ответы:
1. Правило хорошего тона, означает приватную переменную или функцию
2. Шаблонный класс, например vector<int>, vector<std::string>, контейнер может принять разные типы
3. нет
4.
5. Потому что я дурочка и не добавила библиотеку - #include <iostream>. Так, все получается

Инфа:
1. namespace - ft !
2. "friend" перед ф-ей означает, что not member ф-ия может обращаться к приватным полям класса
3. protected - для класса, где объявлена такого типа переменная,она явл приватной, но может наследоваться
4. st2.c - обращаемся к полю "с", класса "st2"
5. "const" в конце функции
 5.1. Нельзя менять содержимое полей в классе (?)
 5.2. Внутри такого ф-ии могут вызываться только те ф-ии, которые тоже const! (Опять же, чтобы ничего не поменять случйно, так как const)
6. Про объявление и реализацию функций в классе/внутри класса. В hpp и cpp файлах
 6.1. Первый способ - это мы пишем объявление и реализацию ф-ии сразу. В hpp файле. Пример:
    void test() {return ;}
 6.2. Второй способ - внутри класса мы обявляем ф-ию, а реализацию пишем вне класса. Все в hpp файле. Пример:
 template <class T, class Allocator>
    class test_class
    {
        public:
            typedef typename std::size_t    test_type;

        test_type test();
    };
    // реализация:
    template <class T, class Allocator> // обязательно указываем, что ф-ия из шаблонного класса
    typename test_class<T, Allocator>::test type // это указываем типа возвращаемого значения функцией. Надо его обязательно достать вот таким образом из класса
    test_class<T, Allocator>::test() // нельзя просто написать название ф-ии. Перед названием надо обязательно прописать "область видимости", из какого класса берем эту функцию. А так как у нас класс еще и шаблонный, то прописываем еще и шаблонные принимаемые параметры.
6.3. Третий способ - объявляем функции внутри класса в .hpp файле. Реализацию пишем в .cpp файле, аналогично пункту 6.2.
 6.3.1. То , что описано выше в 6.3 - не верно. Если выносить реализацию отдельно в cpp файл, то будет ошибка линковки ()
7. Слово "explicit" прописывается в обявлении функции, но не в реализации.
8. Работа с ci (continious integration) для непрерывного проведения тестов во время заливки измененного кода на сервер.
   Будет несколько веток:
   1. main ветка - там будут изменения, которые успешно прошли все тесты
   2. develop ветка - в нее я буду пушить изменения и в ней будут проводиться тесты
9. std::distance - находит разницу между указателями last и first 
10. std::numeric_limits<T> - это шаблонный класс
    Примеры:
    std::numeric_limits<int>::max() - берет максимальное значение инта
    std::numeric_limits<float>::min() - берет минимальное значение float
    ... и так далее
11. static_cast<type_to> (object from); Выполняет все виды преобразования, разрешенные компилятором.
12. Алгоритм реализации reserve:
    1. Выделяем память: new_pbegin = this->alloc.allocate(размер)
    2. Так как создается новая область памяти, 
    вызываем конструктор для нее (new_pbegin), заполняя ее элементами из старого массива (pbegin)
    3. Вызываем деструктор для каждого указателя старой области, начиная с pbegin
    4. С помощью deallocate очищаем старую область памяти
    this->alloc.deallocate(pbegin, размер)
13. traits - это оболочка. Например, есть оболочка над аллокаторами и итераторами (iterator traits).
14. Бывают два вида итератора:
    1. Input - самый простой оператор, могу пройтись по контейнеру только олин раз и только инкрементирую (уменьшать не могу)
    У Input есть дополнение (в коде это наследование):
        1.1. Forward - то же самое, что и input, но могу пройтись несколько раз (это как односвязный список)
        У Forward есть дополнение (в коде это наследование):
            1.1.1. Bidirectional - двухсвязные списки, красно-черные деревья. Могу ходить и вперед и назад.
            У Bidirectional есть дополнение (в коде это наследование):
                1.1.1.1. RandomAccessIterator - он может все)))
    2. Output - он только для того чтобы получать доступ к элементу. Могу залезть и посмотреть само значение элемента
15. Reverse iterator
    Создается из другого итератора, который хотябы bederictional
    Наследуется из std::iterator
16. ptrdiff_t - результат вычитания указателей. Псевдоним одного из фундаментальных целочисленных типов со знаком.
17. Синтаксический сахар - алиас для большого выражения
    ++(*this) = "++" применяется только для объектов (для указателей не применяется!!!)
    

Список дел:
1. Написать адм о продлении
2. Написать бокалу об экзамене без интры
3. Вектора
